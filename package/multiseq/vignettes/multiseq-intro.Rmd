---
title: "An Introduction to the multiseq package"
  output:
  html_document:
    toc: yes
---

<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{An Introduction to the multiseq package}
-->


An Introduction to the multiseq package
=======================================


```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(out.extra='style="display:block; margin: auto"', fig.align="center")
```

The **multiseq** package is an **R** package for multiscale sequence analysis and is ongoing work in the [Stephens lab](http://stephenslab.uchicago.edu) at the University of Chicago. Its main function `multiseq` takes as input an `nsig` by `n` matrix where `nsig` is the number of samples and `n` is the length of the signal. The main function has two modes of operation: smoothing and effect estimation.... Function `multiseq` can be easily applied to smooth and estimate effect in sequencing data thanks to the helper function `get.counts` which extracts data from files in a variety of formats commonly used for storing sequencing data (i.e., *bam*, *rhdf5*, *bigWig* format).


In this vignette you will learn how to install the package, run `multiseq` in its two different modes of operation, get data with function `get.counts`, and visualize its output (and input data) either in **R** or in the [UCSC Genome Browser](https://genome.ucsc.edu/) as a [Track Hub](http://www.genome.ucsc.edu/goldenPath/help/hgTrackHubHelp.html). If input data is sequencing data, you can plot `multiseq` results (tracks) as well as input data in the Genome Browser and you will be able to compare them with any of the available tracks and to fine-tune the display (e.g. zoom and scroll the tracks display, highlight a region, change the order of the displayed tracks, etc).

```{r downloading_and_installing, child = '../README.Rmd'}

```

Smoothing and estimating an effect with `multiseq`
-------------------------------------------------

In this section you will learn how to use `multiseq` to smooth a signal or a set of signals, and how to use it to estimate an effect given a covariate.


Function `multiseq` takes as input `x`, an `nsig` by `n`  matrix (or a one-dimensional vector of size `n`) where `nsig` is the number of samples and `n` is the length of the signal and can perform smoothing on the input signal. You can start by applying `multiseq` to smooth the standard "Spikes" test function used in the wavelet literature for univariate denoising (eg. Antoniadis et al. and Besbeas et al. (2004)). In the Figure below we have plotted the underlying signal in red, the simulated data in black circles, and the baseline estimated by `multiseq` in dark green with    

If multiple samples are available, function `multiseq` can use them jointly to get a better estimate of the underlying signal. You can use 6 samples to estimate the same underlying signal as in the last panel of the Figure below (blue line). 

```{r smoothing}
    #First load the package
    library(multiseq)
 
    spikes <- function(x){
	toreturn <- 0.75*exp(-500*(x-0.23)^2) +
		 1.5*exp(-2000*(x-0.33)^2) +
		 3*exp(-8000*(x-0.47)^2) +
		 2.25*exp(-16000*(x-0.69)^2) +
		 0.5*exp(-32000*(x-0.83)^2)
	return(toreturn)
    }

    n    <- 1024   
    t    <- 1:n/n    
    mu   <- 8/3*(3/16+spikes(t)) 

    #use multiseq to smooth a signal
    x    <- rpois(n, mu)
    res  <- multiseq(x)
    
    #use multiseq to smooth 6 signals simultaneously
    x6          <- t(replicate(6, rpois(n,mu)))
    res6        <- multiseq(x6)
   

    z.threshold <- 2
    ylim        <- c(0, max(c(mu, x, exp(res$baseline.mean+z.threshold*sqrt(res$baseline.var)), exp(res6$baseline.mean+z.threshold*sqrt(res6$baseline.var)))))
    

    #plot
    par(mfrow=c(3,1), oma = c(0,0,0,0) + 0.1, mar = c(2,2,1,2), mgp=c(0,1,0))
    
    #plot underlying signal    		      
    plot(mu, type="l", col="red", ylim=ylim, xaxt="n", xlab="", ylab="")
    legend("topright", legend =c("underlying signal", "simulated data", "estimated signal 1 sample", "estimated signal 6 samples"), lty=c(1, 0, 1, 1), pch=c(".","o",".","."), col=c("red", "black", "dark green", "blue"))  
    title("1", line=-1)    

    #plot simulated data and estimated baseline
    plot(x, ylim=ylim, xaxt="n", xlab="", ylab="")
    lines(exp(res$baseline.mean), col="dark green")
    title("2",line=-1)

    #plot underlyng signal, estimated baseline from 1 samples, and estimated baseline from 6 samples
    plot(mu, type="l", col="red", ylim=ylim, xaxt="n", xlab="", ylab="")
    lines(exp(res$baseline.mean), col="dark green")
    lines(exp(res6$baseline.mean), col="blue")
    title("3",line=-1)
```

As shown above, `multiseq` can be used to smooth multiple samples generated from the same underlying signal to get a better estimate.


Here we will show how `multiseq` can be applied to RNA-Sequencing data. We chose data from an RNA-Seq experiment on 69 lymphoblastoid cell lines derived from unrelated Nigerian individuals (Pickrell et al., Nature 464, 768-772, 2010). In particular we picked a region where SNP rs10774671 was identified to be associated with a differential expression pattern of gene OAS1. For convenience we selected a random subset of 21 samples with 7 samples in each genotype classes and extracted counts around region "chr12:113354417-113358512" (reads mapped with bwa to hg19 genome). Type `?OAS1` to get more information about the dataset. We smoothed counts in each genotype class using `multiseq` (first three panels in the Figure below). A differential expression pattern across genotype classes is evident from the smoothed curves. We applied `multiseq` to the 21 samples given the covariate `g`, the genotype at SNP rs10774671. The 4th panel shows the pattern of differential expression identifyied by `multiseq`. 

```{r OAS1}
    data(OAS1, package="multiseq")

    res0         <- multiseq(x=OAS1$x[OAS1$g==0,], minobs=1, read.depth=OAS1$read.depth[OAS1$g==0])
    res1         <- multiseq(x=OAS1$x[OAS1$g==1,], minobs=1, read.depth=OAS1$read.depth[OAS1$g==1])
    res2         <- multiseq(x=OAS1$x[OAS1$g==2,], minobs=1, read.depth=OAS1$read.depth[OAS1$g==2])
    #res          <- multiseq(x=OAS1$x, g=OAS1$g, minobs=1, read.depth=OAS1$read.depth)
    
    par(mfrow=c(5,1), oma = c(0,0,0,0) + 0.1, mar = c(2,2,1,2), mgp=c(0,1,0))
#    res$region   <- OAS1$region
    ylim         <- c(0, max(res0$baseline.mean+z.threshold*sqrt(res0$baseline.var), res1$baseline.mean+z.threshold*sqrt(res1$baseline.var), res2$baseline.mean+z.threshold*sqrt(res2$baseline.var)))
    plot(res0, z.threshold=2, highlight=FALSE, is.xaxis=FALSE, what="baseline", main="genotype AA", ylim=ylim)
    plot(res1, z.threshold=2, highlight=FALSE, is.xaxis=FALSE, what="baseline", main="genotype AG", ylim=ylim)
    plot(res2, z.threshold=2, highlight=FALSE, is.xaxis=FALSE, what="baseline", main="genotype GG", ylim=ylim)
    #plot(res, z.threshold=2, is.xaxis=FALSE)
    transcripts <- get.transcripts(file.path(path.package("multiseq"),"extdata","hg19.OAS1.refGene.part.gp"), OAS1$region)
    plot(transcripts, OAS1$region)
```

Notice the use of argument `minobs` in function`multiseq` (type `?multiseq` to see a complete list of possible arguments); `minobs` specifies the minimum number of observations ...required to be .. in each logistic model.
Function `get.intervals` that can be used to compute intervals where `multiseq` found strong peaks or strong effects at a specified threshold. Type `?get.intervals` for more details.

```{r plot}
    res$intervals <- get.intervals(res, z.threshold=2, p.threshold=1, what="baseline")
    res$intervals 
```

Function `get.intervals` with argument `what="effect"` outputs intervals where `multiseq` found strong effect (zero is outside of +/- a specified multiple (z.threshold) of the posterior standard deviations). Output interval is in bed format: start is 0-based, end is 1-based.


Extract sequencing data with function `get.counts`
--------------------------------------------------

Special tools are required to handle next generation sequencing data because of their high throughput nature. To show how you can load sequencing data using package **multiseq** we attached to the package an example dataset in bigWig format. Data consists of a ChipSeq experiment from Encode with 4 samples in two groups with factor.... . you can look at the data in folder `file.path(path.package("multiseq"), "extdata")`.

Function `get.counts` extracts data in *bam*, *bigWig*, or *hdf5* format using `samtools`, the *UCSC tools*, or the **R** package **rhdf5**, respectively, and puts them into a matrix format that can be feeded as input to `multiseq`. The path to the input *bam*, *bigWig*, or *hdf5* files has to be specified into a samplesheet with the following format:

    SampleID Type bedPath ReadDepth bigWigPath
    A1 Control peakA1.bb 16335812 A1.bw
    A2 Control peakA2.bb 18197248 A2.bw
    B1 Test peakB1.bb 24225586 B1.bw
    B2 Test peakB2.bb 12378544 B2.bw

The following fields are required: "SampleID" containing sample IDs, "Type" specifying the covariate, "ReadDepth" specifying sequencing depth for each sample, "bigWigPath" and/or "hdf5Path" and/or "bamPath" specifying the absolute path to the input files in *bigWig*, *hdf5*, or *bigWig*, respectively. Field "bedPath" is not required but can be used to specify the path to a *bed* or *bigBed* file (e.g., the path to a *bigBed* file with ChipSeq peaks) and is used by function `samplesheetToTrackHub`. Character "-" is interpreted as missing data:

    SampleID Type bedPath ReadDepth bigWigPath
    A1 Control peakA1.bb 16335812 A1.bw
    A2 Control - 18197248 A2.bw
  
Let's use function `get.counts` to load our bigWig files:
```{r load_seq_data}
    setwd(file.path(path.package("multiseq"), "extdata"));
    samplesheet <- file.path(path.package("multiseq"),"extdata","samplesheetEncode.txt")
    samples     <- read.table(samplesheet, stringsAsFactors=F, header=T)
    g <- factor(samples$Type)
    g <- match(g, levels(g))-1
    if (noExecutable("wigToBigWig")){
       data(dat, package="multiseq")
       region      <- dat$region
       x <- dat$x
    }else{
       region      <- "chr1:11740409-11756792"
       x           <- get.counts(samplesheet, region) 
    }
```
If you didn't follow the "optional installation steps" described in a previous section (`noExecutable("wigToBigWig")==TRUE`), you won't be able to load the bigWig files with function `get.counts`. You can anyways upload the dat using `data(dat, package="multiseq")`.

Let's apply `multiseq` to smooth the data in each of the two genotipe classes (`g=0` and `g=1`) and then let's apply `multiseq` to find an effect given the covariate `g`:

```{r testing_on_chipseq}
      #smooth data in each genotype class
      res0        <- multiseq(x=x[which(g==0),], minobs=1, read.depth=samples$ReadDepth[which(g==0)])
      res1  	  <- multiseq(x=x[which(g==1),], minobs=1, read.depth=samples$ReadDepth[which(g==1)]) 
      #find an effect given a covariate
      #res         <- multiseq(x=x, g=g, minobs=1, read.depth=samples$ReadDepth)

      #plot
      par(mfrow=c(3,1), oma = c(0,0,0,0) + 0.1, mar = c(2,2,1,2), mgp=c(0,1,0))
      #res$region <- region
      ylim         <- c(0, max(res0$baseline.mean+z.threshold*sqrt(res0$baseline.var), res1$baseline.mean+z.threshold*sqrt(res1$baseline.var)))
      plot(res0, z.threshold=2, is.xaxis=FALSE, what="baseline", main=samples$Type[g==0][1], ylim=ylim)
      plot(res1, z.threshold=2, is.xaxis=FALSE, what="baseline", main=samples$Type[g==1][1], ylim=ylim)
      #plot(res, z.threshold=2)
```


### Visualizing input data using `samplesheetToTrackHub`


With function `samplesheetToTrackHub` you can create a [Track Hub](http://www.genome.ucsc.edu/goldenPath/help/hgTrackHubHelp.html) and visualize your input data in the [UCSC Genome Browser](https://genome.ucsc.edu/). Before you use this function, follow installation instructions in the "Optional steps" paragraph above.

```{r track_hub, results='hide'}
    setwd(file.path(path.package("multiseq"),"extdata"))
    hub_name <- "testMultiseq/dat"
    #samplesheetToTrackHub(samplesheet, hub_name, chr="chr1")
```

Function `samplesheetToTrackHub` will create a Track Hub in folder */some/path/testMultiseq/dat/* and will print the following message:

    go to http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&hubUrl=https:some/address/testMultiseq/dat/hub.txt
    center the genome browser on the region of interest
    and make track visible

If the read tracks or the bed files are large, make sure enough memory is available to run `samplesheetToTrackHub`.


Visualizing output data using `multiseqToTrackHub`
--------------------------------------------------------------------------------------


After running `multiseq`, you can use function `multiseqToTrackHub` to create a Track Hub that can be visualized in the UCSC Genome Browser to display
- the effect +/- a specified multiple (z.threshold) of the posterior standard deviation
- the intervals where multiseq found strong effect (zero is outside of +/- a multiple of the posterior standard deviation ' e.g. 2 or 3).

```{r multiseqToTrackHub, results='hide'}
    #res$region    <- region
    #res$intervals <- get.intervals(res, z.threshold=2, region=region, what="effect")
    #multiseqToTrackHub(res, z.threshold=2, hub_name="testMultiseq/multiseq_dat")
```

Function `multiseqToTrackHub` will create a Track Hub named *multiseq_dat* in the *https:some/address/testMultiseq/* folder and will print the following message:
  
    go to http://genome.ucsc.edu/cgi-bin/hgTracks?db=hg19&hubUrl=https:some/address/testMultiseq/multiseq_dat/hub.txt
    center your genome browser around chr1:11740409-11756792 
    and make track visible
    
By default `multiseqToTrackHub` uses the human genome hg19 but default settings can be changed by specifying additional arguments (see help).

This is a screenshot of both the `samplesheet` and `multiseq` Track Hub in the UCSC Genome Browser:
#############![Image](../inst/extdata/dat/dat.png)

Note
----
If the Genome Browser doesn't show the Track Hub try going to http://genome.ucsc.edu/cgi-bin/hgHubConnect/MyHubs and checking the Track Hub.